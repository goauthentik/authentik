"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePreset = exports.resolveStyleguideConfig = exports.resolveApis = exports.resolvePlugins = exports.resolveConfig = exports.resolveConfigFileAndRefs = void 0;
const path = require("path");
const ref_utils_1 = require("../ref-utils");
const utils_1 = require("../utils");
const resolve_1 = require("../resolve");
const builtIn_1 = require("./builtIn");
const utils_2 = require("./utils");
const env_1 = require("../env");
const utils_3 = require("../utils");
const config_1 = require("./config");
const logger_1 = require("../logger");
const asserts_1 = require("../rules/common/assertions/asserts");
const types_1 = require("../types");
const redocly_yaml_1 = require("../types/redocly-yaml");
function resolveConfigFileAndRefs({ configPath, externalRefResolver = new resolve_1.BaseResolver(), base = null, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!configPath) {
            throw new Error('Reference to a config is required.\n');
        }
        const document = yield externalRefResolver.resolveDocument(base, configPath, true);
        if (document instanceof Error) {
            throw document;
        }
        const types = (0, types_1.normalizeTypes)(redocly_yaml_1.ConfigTypes);
        const resolvedRefMap = yield (0, resolve_1.resolveDocument)({
            rootDocument: document,
            rootType: types.ConfigRoot,
            externalRefResolver,
        });
        return { document, resolvedRefMap };
    });
}
exports.resolveConfigFileAndRefs = resolveConfigFileAndRefs;
function resolveConfig({ rawConfig, configPath, externalRefResolver, }) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        if ((_b = (_a = rawConfig.styleguide) === null || _a === void 0 ? void 0 : _a.extends) === null || _b === void 0 ? void 0 : _b.some(utils_3.isNotString)) {
            throw new Error(`Error configuration format not detected in extends value must contain strings`);
        }
        const resolver = externalRefResolver !== null && externalRefResolver !== void 0 ? externalRefResolver : new resolve_1.BaseResolver((0, utils_2.getResolveConfig)(rawConfig.resolve));
        const apis = yield resolveApis({
            rawConfig,
            configPath,
            resolver,
        });
        const styleguide = yield resolveStyleguideConfig({
            styleguideConfig: rawConfig.styleguide,
            configPath,
            resolver,
        });
        return new config_1.Config(Object.assign(Object.assign({}, rawConfig), { apis,
            styleguide }), configPath);
    });
}
exports.resolveConfig = resolveConfig;
function resolvePlugins(plugins, configPath = '') {
    if (!plugins)
        return [];
    // TODO: implement or reuse Resolver approach so it will work in node and browser envs
    const requireFunc = (plugin) => {
        if (env_1.isBrowser && (0, utils_3.isString)(plugin)) {
            logger_1.logger.error(`Cannot load ${plugin}. Plugins aren't supported in browser yet.`);
            return undefined;
        }
        if ((0, utils_3.isString)(plugin)) {
            try {
                const absoltePluginPath = path.resolve(path.dirname(configPath), plugin);
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                return typeof __webpack_require__ === 'function'
                    ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        __non_webpack_require__(absoltePluginPath)
                    : require(absoltePluginPath);
            }
            catch (e) {
                if (e instanceof SyntaxError) {
                    throw e;
                }
                throw new Error(`Failed to load plugin "${plugin}". Please provide a valid path`);
            }
        }
        return plugin;
    };
    const seenPluginIds = new Map();
    return plugins
        .map((p) => {
        if ((0, utils_3.isString)(p) && (0, ref_utils_1.isAbsoluteUrl)(p)) {
            throw new Error(logger_1.colorize.red(`We don't support remote plugins yet.`));
        }
        // TODO: resolve npm packages similar to eslint
        const pluginModule = requireFunc(p);
        if (!pluginModule) {
            return;
        }
        const id = pluginModule.id;
        if (typeof id !== 'string') {
            throw new Error(logger_1.colorize.red(`Plugin must define \`id\` property in ${logger_1.colorize.blue(p.toString())}.`));
        }
        if (seenPluginIds.has(id)) {
            const pluginPath = seenPluginIds.get(id);
            throw new Error(logger_1.colorize.red(`Plugin "id" must be unique. Plugin ${logger_1.colorize.blue(p.toString())} uses id "${logger_1.colorize.blue(id)}" already seen in ${logger_1.colorize.blue(pluginPath)}`));
        }
        seenPluginIds.set(id, p.toString());
        const plugin = Object.assign(Object.assign({ id }, (pluginModule.configs ? { configs: pluginModule.configs } : {})), (pluginModule.typeExtension ? { typeExtension: pluginModule.typeExtension } : {}));
        if (pluginModule.rules) {
            if (!pluginModule.rules.oas3 && !pluginModule.rules.oas2 && !pluginModule.rules.async2) {
                throw new Error(`Plugin rules must have \`oas3\`, \`oas2\` or \`async2\` rules "${p}.`);
            }
            plugin.rules = {};
            if (pluginModule.rules.oas3) {
                plugin.rules.oas3 = (0, utils_2.prefixRules)(pluginModule.rules.oas3, id);
            }
            if (pluginModule.rules.oas2) {
                plugin.rules.oas2 = (0, utils_2.prefixRules)(pluginModule.rules.oas2, id);
            }
            if (pluginModule.rules.async2) {
                plugin.rules.async2 = (0, utils_2.prefixRules)(pluginModule.rules.async2, id);
            }
        }
        if (pluginModule.preprocessors) {
            if (!pluginModule.preprocessors.oas3 &&
                !pluginModule.preprocessors.oas2 &&
                !pluginModule.preprocessors.async2) {
                throw new Error(`Plugin \`preprocessors\` must have \`oas3\`, \`oas2\` or \`async2\` preprocessors "${p}.`);
            }
            plugin.preprocessors = {};
            if (pluginModule.preprocessors.oas3) {
                plugin.preprocessors.oas3 = (0, utils_2.prefixRules)(pluginModule.preprocessors.oas3, id);
            }
            if (pluginModule.preprocessors.oas2) {
                plugin.preprocessors.oas2 = (0, utils_2.prefixRules)(pluginModule.preprocessors.oas2, id);
            }
            if (pluginModule.preprocessors.async2) {
                plugin.preprocessors.async2 = (0, utils_2.prefixRules)(pluginModule.preprocessors.async2, id);
            }
        }
        if (pluginModule.decorators) {
            if (!pluginModule.decorators.oas3 &&
                !pluginModule.decorators.oas2 &&
                !pluginModule.decorators.async2) {
                throw new Error(`Plugin \`decorators\` must have \`oas3\`, \`oas2\` or \`async2\` decorators "${p}.`);
            }
            plugin.decorators = {};
            if (pluginModule.decorators.oas3) {
                plugin.decorators.oas3 = (0, utils_2.prefixRules)(pluginModule.decorators.oas3, id);
            }
            if (pluginModule.decorators.oas2) {
                plugin.decorators.oas2 = (0, utils_2.prefixRules)(pluginModule.decorators.oas2, id);
            }
            if (pluginModule.decorators.async2) {
                plugin.decorators.async2 = (0, utils_2.prefixRules)(pluginModule.decorators.async2, id);
            }
        }
        if (pluginModule.assertions) {
            plugin.assertions = pluginModule.assertions;
        }
        return plugin;
    })
        .filter(utils_3.isDefined);
}
exports.resolvePlugins = resolvePlugins;
function resolveApis({ rawConfig, configPath = '', resolver, }) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { apis = {}, styleguide: styleguideConfig = {} } = rawConfig;
        const resolvedApis = {};
        for (const [apiName, apiContent] of Object.entries(apis || {})) {
            if ((_b = (_a = apiContent.styleguide) === null || _a === void 0 ? void 0 : _a.extends) === null || _b === void 0 ? void 0 : _b.some(utils_3.isNotString)) {
                throw new Error(`Error configuration format not detected in extends value must contain strings`);
            }
            const rawStyleguideConfig = getMergedRawStyleguideConfig(styleguideConfig, apiContent.styleguide);
            const resolvedApiConfig = yield resolveStyleguideConfig({
                styleguideConfig: rawStyleguideConfig,
                configPath,
                resolver,
            });
            resolvedApis[apiName] = Object.assign(Object.assign({}, apiContent), { styleguide: resolvedApiConfig });
        }
        return resolvedApis;
    });
}
exports.resolveApis = resolveApis;
function resolveAndMergeNestedStyleguideConfig({ styleguideConfig, configPath = '', resolver = new resolve_1.BaseResolver(), }, parentConfigPaths = [], extendPaths = []) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        if (parentConfigPaths.includes(configPath)) {
            throw new Error(`Circular dependency in config file: "${configPath}"`);
        }
        const plugins = (0, utils_2.getUniquePlugins)(resolvePlugins([...((styleguideConfig === null || styleguideConfig === void 0 ? void 0 : styleguideConfig.plugins) || []), builtIn_1.defaultPlugin], configPath));
        const pluginPaths = (_a = styleguideConfig === null || styleguideConfig === void 0 ? void 0 : styleguideConfig.plugins) === null || _a === void 0 ? void 0 : _a.filter(utils_3.isString).map((p) => path.resolve(path.dirname(configPath), p));
        const resolvedConfigPath = (0, ref_utils_1.isAbsoluteUrl)(configPath)
            ? configPath
            : configPath && path.resolve(configPath);
        const extendConfigs = yield Promise.all(((_b = styleguideConfig === null || styleguideConfig === void 0 ? void 0 : styleguideConfig.extends) === null || _b === void 0 ? void 0 : _b.map((presetItem) => __awaiter(this, void 0, void 0, function* () {
            if (!(0, ref_utils_1.isAbsoluteUrl)(presetItem) && !path.extname(presetItem)) {
                return resolvePreset(presetItem, plugins);
            }
            const pathItem = (0, ref_utils_1.isAbsoluteUrl)(presetItem)
                ? presetItem
                : (0, ref_utils_1.isAbsoluteUrl)(configPath)
                    ? new URL(presetItem, configPath).href
                    : path.resolve(path.dirname(configPath), presetItem);
            const extendedStyleguideConfig = yield loadExtendStyleguideConfig(pathItem, resolver);
            return yield resolveAndMergeNestedStyleguideConfig({
                styleguideConfig: extendedStyleguideConfig,
                configPath: pathItem,
                resolver: resolver,
            }, [...parentConfigPaths, resolvedConfigPath], extendPaths);
        }))) || []);
        const _d = (0, utils_2.mergeExtends)([
            ...extendConfigs,
            Object.assign(Object.assign({}, styleguideConfig), { plugins, extends: undefined, extendPaths: [...parentConfigPaths, resolvedConfigPath], pluginPaths }),
        ]), { plugins: mergedPlugins = [] } = _d, styleguide = __rest(_d, ["plugins"]);
        return Object.assign(Object.assign({}, styleguide), { extendPaths: (_c = styleguide.extendPaths) === null || _c === void 0 ? void 0 : _c.filter((path) => path && !(0, ref_utils_1.isAbsoluteUrl)(path)), plugins: (0, utils_2.getUniquePlugins)(mergedPlugins), recommendedFallback: styleguideConfig === null || styleguideConfig === void 0 ? void 0 : styleguideConfig.recommendedFallback, doNotResolveExamples: styleguideConfig === null || styleguideConfig === void 0 ? void 0 : styleguideConfig.doNotResolveExamples });
    });
}
function resolveStyleguideConfig(opts, parentConfigPaths = [], extendPaths = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolvedStyleguideConfig = yield resolveAndMergeNestedStyleguideConfig(opts, parentConfigPaths, extendPaths);
        return Object.assign(Object.assign({}, resolvedStyleguideConfig), { rules: resolvedStyleguideConfig.rules && groupStyleguideAssertionRules(resolvedStyleguideConfig) });
    });
}
exports.resolveStyleguideConfig = resolveStyleguideConfig;
function resolvePreset(presetName, plugins) {
    var _a;
    const { pluginId, configName } = (0, utils_2.parsePresetName)(presetName);
    const plugin = plugins.find((p) => p.id === pluginId);
    if (!plugin) {
        throw new Error(`Invalid config ${logger_1.colorize.red(presetName)}: plugin ${pluginId} is not included.`);
    }
    const preset = (_a = plugin.configs) === null || _a === void 0 ? void 0 : _a[configName];
    if (!preset) {
        throw new Error(pluginId
            ? `Invalid config ${logger_1.colorize.red(presetName)}: plugin ${pluginId} doesn't export config with name ${configName}.`
            : `Invalid config ${logger_1.colorize.red(presetName)}: there is no such built-in config.`);
    }
    return preset;
}
exports.resolvePreset = resolvePreset;
function loadExtendStyleguideConfig(filePath, resolver) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { parsed } = (yield resolver.resolveDocument(null, filePath));
            const rawConfig = (0, utils_2.transformConfig)(parsed);
            if (!rawConfig.styleguide) {
                throw new Error(`Styleguide configuration format not detected: "${filePath}"`);
            }
            return rawConfig.styleguide;
        }
        catch (error) {
            throw new Error(`Failed to load "${filePath}": ${error.message}`);
        }
    });
}
function getMergedRawStyleguideConfig(rootStyleguideConfig, apiStyleguideConfig) {
    const resultLint = Object.assign(Object.assign(Object.assign({}, rootStyleguideConfig), (0, utils_1.pickDefined)(apiStyleguideConfig)), { rules: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.rules), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.rules), oas2Rules: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas2Rules), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas2Rules), oas3_0Rules: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas3_0Rules), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas3_0Rules), oas3_1Rules: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas3_1Rules), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas3_1Rules), preprocessors: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.preprocessors), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.preprocessors), oas2Preprocessors: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas2Preprocessors), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas2Preprocessors), oas3_0Preprocessors: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas3_0Preprocessors), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas3_0Preprocessors), oas3_1Preprocessors: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas3_1Preprocessors), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas3_1Preprocessors), decorators: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.decorators), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.decorators), oas2Decorators: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas2Decorators), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas2Decorators), oas3_0Decorators: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas3_0Decorators), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas3_0Decorators), oas3_1Decorators: Object.assign(Object.assign({}, rootStyleguideConfig === null || rootStyleguideConfig === void 0 ? void 0 : rootStyleguideConfig.oas3_1Decorators), apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.oas3_1Decorators), recommendedFallback: (apiStyleguideConfig === null || apiStyleguideConfig === void 0 ? void 0 : apiStyleguideConfig.extends)
            ? false
            : rootStyleguideConfig.recommendedFallback });
    return resultLint;
}
function groupStyleguideAssertionRules({ rules, plugins, }) {
    if (!rules) {
        return rules;
    }
    // Create a new record to avoid mutating original
    const transformedRules = {};
    // Collect assertion rules
    const assertions = [];
    for (const [ruleKey, rule] of Object.entries(rules)) {
        // keep the old assert/ syntax as an alias
        if ((ruleKey.startsWith('rule/') || ruleKey.startsWith('assert/')) &&
            typeof rule === 'object' &&
            rule !== null) {
            const assertion = rule;
            if (plugins) {
                registerCustomAssertions(plugins, assertion);
                // We may have custom assertion inside where block
                for (const context of assertion.where || []) {
                    registerCustomAssertions(plugins, context);
                }
            }
            assertions.push(Object.assign(Object.assign({}, assertion), { assertionId: ruleKey }));
        }
        else {
            // If it's not an assertion, keep it as is
            transformedRules[ruleKey] = rule;
        }
    }
    if (assertions.length > 0) {
        transformedRules.assertions = assertions;
    }
    return transformedRules;
}
function registerCustomAssertions(plugins, assertion) {
    for (const field of (0, utils_3.keysOf)(assertion.assertions)) {
        const [pluginId, fn] = field.split('/');
        if (!pluginId || !fn)
            continue;
        const plugin = plugins.find((plugin) => plugin.id === pluginId);
        if (!plugin) {
            throw Error(logger_1.colorize.red(`Plugin ${logger_1.colorize.blue(pluginId)} isn't found.`));
        }
        if (!plugin.assertions || !plugin.assertions[fn]) {
            throw Error(`Plugin ${logger_1.colorize.red(pluginId)} doesn't export assertions function with name ${logger_1.colorize.red(fn)}.`);
        }
        asserts_1.asserts[field] = (0, asserts_1.buildAssertCustomFunction)(plugin.assertions[fn]);
    }
}
