import type { NormalizedNodeType } from './types';
import type { Stack } from './utils';
import type { UserContext, ResolveResult, ProblemSeverity } from './walk';
import type { Location } from './ref-utils';
import type { Oas3Definition, Oas3ExternalDocs, Oas3Info, Oas3Contact, Oas3Components, Oas3License, Oas3Schema, Oas3Header, Oas3Parameter, Oas3Operation, Oas3PathItem, Oas3ServerVariable, Oas3Server, Oas3MediaType, Oas3Response, Oas3Example, Oas3RequestBody, Oas3Tag, OasRef, Oas3SecurityScheme, Oas3SecurityRequirement, Oas3Encoding, Oas3Link, Oas3Xml, Oas3Discriminator, Oas3Callback } from './typings/openapi';
import type { Oas2Definition, Oas2Tag, Oas2ExternalDocs, Oas2SecurityRequirement, Oas2Info, Oas2Contact, Oas2License, Oas2PathItem, Oas2Operation, Oas2Header, Oas2Response, Oas2Schema, Oas2Xml, Oas2Parameter, Oas2SecurityScheme } from './typings/swagger';
import type { Async2Definition } from './typings/asyncapi';
export type SkipFunctionContext = Pick<UserContext, 'location' | 'rawNode' | 'resolve' | 'rawLocation'>;
export type VisitFunction<T> = (node: T, ctx: UserContext & {
    ignoreNextVisitorsOnNode: () => void;
}, parents?: any, context?: any) => void;
type VisitRefFunction = (node: OasRef, ctx: UserContext, resolved: ResolveResult<any>) => void;
type SkipFunction<T> = (node: T, key: string | number, ctx: SkipFunctionContext) => boolean;
type VisitObject<T> = {
    enter?: VisitFunction<T>;
    leave?: VisitFunction<T>;
    skip?: SkipFunction<T>;
};
export type NestedVisitObject<T, P> = VisitObject<T> & NestedVisitor<P>;
type VisitFunctionOrObject<T> = VisitFunction<T> | VisitObject<T>;
export type VisitorNode<T> = {
    ruleId: string;
    severity: ProblemSeverity;
    context: VisitorLevelContext | VisitorSkippedLevelContext;
    depth: number;
    visit: VisitFunction<T>;
    skip?: SkipFunction<T>;
};
type VisitorRefNode = {
    ruleId: string;
    severity: ProblemSeverity;
    context: VisitorLevelContext;
    depth: number;
    visit: VisitRefFunction;
};
export type VisitorLevelContext = {
    isSkippedLevel: false;
    type: NormalizedNodeType;
    parent: VisitorLevelContext | null;
    activatedOn: Stack<{
        node?: any;
        withParentNode?: any;
        skipped: boolean;
        nextLevelTypeActivated: Stack<NormalizedNodeType>;
        location?: Location;
    }>;
};
export type VisitorSkippedLevelContext = {
    isSkippedLevel: true;
    parent: VisitorLevelContext;
    seen: Set<any>;
};
export type NormalizeVisitor<Fn> = Fn extends VisitFunction<infer T> ? VisitorNode<T> : never;
export type BaseVisitor = {
    any?: {
        enter?: VisitFunction<any>;
        leave?: VisitFunction<any>;
        skip?: SkipFunction<any>;
    } | VisitFunction<any>;
    ref?: {
        enter?: VisitRefFunction;
        leave?: VisitRefFunction;
    } | VisitRefFunction;
};
type Oas3FlatVisitor = {
    Root?: VisitFunctionOrObject<Oas3Definition>;
    Tag?: VisitFunctionOrObject<Oas3Tag>;
    ExternalDocs?: VisitFunctionOrObject<Oas3ExternalDocs>;
    Server?: VisitFunctionOrObject<Oas3Server>;
    ServerVariable?: VisitFunctionOrObject<Oas3ServerVariable>;
    SecurityRequirement?: VisitFunctionOrObject<Oas3SecurityRequirement>;
    Info?: VisitFunctionOrObject<Oas3Info>;
    Contact?: VisitFunctionOrObject<Oas3Contact>;
    License?: VisitFunctionOrObject<Oas3License>;
    Paths?: VisitFunctionOrObject<Record<string, Oas3PathItem>>;
    PathItem?: VisitFunctionOrObject<Oas3PathItem>;
    Callback?: VisitFunctionOrObject<Oas3Callback>;
    CallbacksMap?: VisitFunctionOrObject<Record<string, Oas3Callback>>;
    Parameter?: VisitFunctionOrObject<Oas3Parameter>;
    Operation?: VisitFunctionOrObject<Oas3Operation>;
    RequestBody?: VisitFunctionOrObject<Oas3RequestBody>;
    MediaTypesMap?: VisitFunctionOrObject<Record<string, Oas3MediaType>>;
    MediaType?: VisitFunctionOrObject<Oas3MediaType>;
    Example?: VisitFunctionOrObject<Oas3Example>;
    Encoding?: VisitFunctionOrObject<Oas3Encoding>;
    Header?: VisitFunctionOrObject<Oas3Header>;
    Responses?: VisitFunctionOrObject<Record<string, Oas3Response>>;
    Response?: VisitFunctionOrObject<Oas3Response>;
    Link?: VisitFunctionOrObject<Oas3Link>;
    Schema?: VisitFunctionOrObject<Oas3Schema>;
    Xml?: VisitFunctionOrObject<Oas3Xml>;
    SchemaProperties?: VisitFunctionOrObject<Record<string, Oas3Schema>>;
    DiscriminatorMapping?: VisitFunctionOrObject<Record<string, string>>;
    Discriminator?: VisitFunctionOrObject<Oas3Discriminator>;
    Components?: VisitFunctionOrObject<Oas3Components>;
    NamedSchemas?: VisitFunctionOrObject<Record<string, Oas3Schema>>;
    NamedResponses?: VisitFunctionOrObject<Record<string, Oas3Response>>;
    NamedParameters?: VisitFunctionOrObject<Record<string, Oas3Parameter>>;
    NamedExamples?: VisitFunctionOrObject<Record<string, Oas3Example>>;
    NamedRequestBodies?: VisitFunctionOrObject<Record<string, Oas3RequestBody>>;
    NamedHeaders?: VisitFunctionOrObject<Record<string, Oas3Header>>;
    NamedSecuritySchemes?: VisitFunctionOrObject<Record<string, Oas3SecurityScheme>>;
    NamedLinks?: VisitFunctionOrObject<Record<string, Oas3Link>>;
    NamedCallbacks?: VisitFunctionOrObject<Record<string, Oas3Callback>>;
    ImplicitFlow?: VisitFunctionOrObject<Oas3SecurityScheme['flows']['implicit']>;
    PasswordFlow?: VisitFunctionOrObject<Oas3SecurityScheme['flows']['password']>;
    ClientCredentials?: VisitFunctionOrObject<Oas3SecurityScheme['flows']['clientCredentials']>;
    AuthorizationCode?: VisitFunctionOrObject<Oas3SecurityScheme['flows']['authorizationCode']>;
    OAuth2Flows?: VisitFunctionOrObject<Oas3SecurityScheme['flows']>;
    SecurityScheme?: VisitFunctionOrObject<Oas3SecurityScheme>;
    SpecExtension?: VisitFunctionOrObject<unknown>;
};
type Oas2FlatVisitor = {
    Root?: VisitFunctionOrObject<Oas2Definition>;
    Tag?: VisitFunctionOrObject<Oas2Tag>;
    ExternalDocs?: VisitFunctionOrObject<Oas2ExternalDocs>;
    SecurityRequirement?: VisitFunctionOrObject<Oas2SecurityRequirement>;
    Info?: VisitFunctionOrObject<Oas2Info>;
    Contact?: VisitFunctionOrObject<Oas2Contact>;
    License?: VisitFunctionOrObject<Oas2License>;
    Paths?: VisitFunctionOrObject<Record<string, Oas2PathItem>>;
    PathItem?: VisitFunctionOrObject<Oas2PathItem>;
    Parameter?: VisitFunctionOrObject<any>;
    Operation?: VisitFunctionOrObject<Oas2Operation>;
    Examples?: VisitFunctionOrObject<Record<string, any>>;
    Header?: VisitFunctionOrObject<Oas2Header>;
    Responses?: VisitFunctionOrObject<Record<string, Oas2Response>>;
    Response?: VisitFunctionOrObject<Oas2Response>;
    Schema?: VisitFunctionOrObject<Oas2Schema>;
    Xml?: VisitFunctionOrObject<Oas2Xml>;
    SchemaProperties?: VisitFunctionOrObject<Record<string, Oas2Schema>>;
    NamedSchemas?: VisitFunctionOrObject<Record<string, Oas2Schema>>;
    NamedResponses?: VisitFunctionOrObject<Record<string, Oas2Response>>;
    NamedParameters?: VisitFunctionOrObject<Record<string, Oas2Parameter>>;
    SecurityScheme?: VisitFunctionOrObject<Oas2SecurityScheme>;
    NamedSecuritySchemes?: VisitFunctionOrObject<Record<string, Oas2SecurityScheme>>;
    SpecExtension?: VisitFunctionOrObject<unknown>;
};
type Async2FlatVisitor = {
    Root?: VisitFunctionOrObject<Async2Definition>;
};
type Oas3NestedVisitor = {
    [T in keyof Oas3FlatVisitor]: Oas3FlatVisitor[T] extends Function ? Oas3FlatVisitor[T] : Oas3FlatVisitor[T] & NestedVisitor<Oas3NestedVisitor>;
};
type Oas2NestedVisitor = {
    [T in keyof Oas2FlatVisitor]: Oas2FlatVisitor[T] extends Function ? Oas2FlatVisitor[T] : Oas2FlatVisitor[T] & NestedVisitor<Oas2NestedVisitor>;
};
type Async2NestedVisitor = {
    [T in keyof Async2FlatVisitor]: Async2FlatVisitor[T] extends Function ? Async2FlatVisitor[T] : Async2FlatVisitor[T] & NestedVisitor<Async2NestedVisitor>;
};
export type Oas3Visitor = BaseVisitor & Oas3NestedVisitor & Record<string, VisitFunction<any> | NestedVisitObject<any, Oas3NestedVisitor>>;
export type Oas2Visitor = BaseVisitor & Oas2NestedVisitor & Record<string, VisitFunction<any> | NestedVisitObject<any, Oas2NestedVisitor>>;
export type Async2Visitor = BaseVisitor & Async2NestedVisitor & Record<string, VisitFunction<any> | NestedVisitObject<any, Async2NestedVisitor>>;
export type NestedVisitor<T> = Exclude<T, 'any' | 'ref' | 'Root'>;
export type NormalizedOasVisitors<T extends BaseVisitor> = {
    [V in keyof T]-?: {
        enter: Array<NormalizeVisitor<T[V]>>;
        leave: Array<NormalizeVisitor<T[V]>>;
    };
} & {
    ref: {
        enter: Array<VisitorRefNode>;
        leave: Array<VisitorRefNode>;
    };
    [k: string]: {
        enter: Array<VisitorNode<any>>;
        leave: Array<VisitorNode<any>>;
    };
};
export type Oas3Rule = (options: Record<string, any>) => Oas3Visitor | Oas3Visitor[];
export type Oas2Rule = (options: Record<string, any>) => Oas2Visitor | Oas2Visitor[];
export type Async2Rule = (options: Record<string, any>) => Async2Visitor | Async2Visitor[];
export type Oas3Preprocessor = (options: Record<string, any>) => Oas3Visitor;
export type Oas2Preprocessor = (options: Record<string, any>) => Oas2Visitor;
export type Async2Preprocessor = (options: Record<string, any>) => Async2Visitor;
export type Oas3Decorator = (options: Record<string, any>) => Oas3Visitor;
export type Oas2Decorator = (options: Record<string, any>) => Oas2Visitor;
export type Async2Decorator = (options: Record<string, any>) => Async2Visitor;
export type OasRule = Oas3Rule;
export type OasPreprocessor = Oas3Preprocessor;
export type OasDecorator = Oas3Decorator;
export type RuleInstanceConfig = {
    ruleId: string;
    severity: ProblemSeverity;
};
export declare function normalizeVisitors<T extends BaseVisitor>(visitorsConfig: (RuleInstanceConfig & {
    visitor: NestedVisitObject<unknown, T>;
})[], types: Record<keyof T, NormalizedNodeType>): NormalizedOasVisitors<T>;
export {};
