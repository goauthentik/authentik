"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintConfig = exports.lintDocument = exports.lintFromString = exports.lint = void 0;
const resolve_1 = require("./resolve");
const visitors_1 = require("./visitors");
const walk_1 = require("./walk");
const config_1 = require("./config");
const types_1 = require("./types");
const ajv_1 = require("./rules/ajv");
const oas_types_1 = require("./oas-types");
const redocly_yaml_1 = require("./types/redocly-yaml");
const spec_1 = require("./rules/common/spec");
const no_unresolved_refs_1 = require("./rules/no-unresolved-refs");
function lint(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { ref, externalRefResolver = new resolve_1.BaseResolver(opts.config.resolve) } = opts;
        const document = (yield externalRefResolver.resolveDocument(null, ref, true));
        return lintDocument(Object.assign(Object.assign({ document }, opts), { externalRefResolver, config: opts.config.styleguide }));
    });
}
exports.lint = lint;
function lintFromString(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { source, absoluteRef, externalRefResolver = new resolve_1.BaseResolver(opts.config.resolve) } = opts;
        const document = (0, resolve_1.makeDocumentFromString)(source, absoluteRef || '/');
        return lintDocument(Object.assign(Object.assign({ document }, opts), { externalRefResolver, config: opts.config.styleguide }));
    });
}
exports.lintFromString = lintFromString;
function lintDocument(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, ajv_1.releaseAjvInstance)(); // FIXME: preprocessors can modify nodes which are then cached to ajv-instance by absolute path
        const { document, customTypes, externalRefResolver, config } = opts;
        const specVersion = (0, oas_types_1.detectSpec)(document.parsed);
        const specMajorVersion = (0, oas_types_1.getMajorSpecVersion)(specVersion);
        const rules = config.getRulesForOasVersion(specMajorVersion);
        const types = (0, types_1.normalizeTypes)(config.extendTypes(customTypes !== null && customTypes !== void 0 ? customTypes : (0, oas_types_1.getTypes)(specVersion), specVersion), config);
        const ctx = {
            problems: [],
            oasVersion: specVersion,
            visitorsData: {},
        };
        const preprocessors = (0, config_1.initRules)(rules, config, 'preprocessors', specVersion);
        const regularRules = (0, config_1.initRules)(rules, config, 'rules', specVersion);
        let resolvedRefMap = yield (0, resolve_1.resolveDocument)({
            rootDocument: document,
            rootType: types.Root,
            externalRefResolver,
        });
        if (preprocessors.length > 0) {
            // Make additional pass to resolve refs defined in preprocessors.
            (0, walk_1.walkDocument)({
                document,
                rootType: types.Root,
                normalizedVisitors: (0, visitors_1.normalizeVisitors)(preprocessors, types),
                resolvedRefMap,
                ctx,
            });
            resolvedRefMap = yield (0, resolve_1.resolveDocument)({
                rootDocument: document,
                rootType: types.Root,
                externalRefResolver,
            });
        }
        const normalizedVisitors = (0, visitors_1.normalizeVisitors)(regularRules, types);
        (0, walk_1.walkDocument)({
            document,
            rootType: types.Root,
            normalizedVisitors,
            resolvedRefMap,
            ctx,
        });
        return ctx.problems.map((problem) => config.addProblemToIgnore(problem));
    });
}
exports.lintDocument = lintDocument;
function lintConfig(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { document, severity, externalRefResolver = new resolve_1.BaseResolver() } = opts;
        const ctx = {
            problems: [],
            oasVersion: oas_types_1.SpecVersion.OAS3_0,
            visitorsData: {},
        };
        const plugins = (0, config_1.resolvePlugins)([config_1.defaultPlugin]);
        const config = new config_1.StyleguideConfig({
            plugins,
            rules: { spec: 'error' },
        });
        const types = (0, types_1.normalizeTypes)(opts.externalConfigTypes || redocly_yaml_1.ConfigTypes, config);
        const rules = [
            {
                severity: severity || 'error',
                ruleId: 'configuration spec',
                visitor: (0, spec_1.Spec)({ severity: 'error' }),
            },
            {
                severity: severity || 'error',
                ruleId: 'configuration no-unresolved-refs',
                visitor: (0, no_unresolved_refs_1.NoUnresolvedRefs)({ severity: 'error' }),
            },
        ];
        const normalizedVisitors = (0, visitors_1.normalizeVisitors)(rules, types);
        const resolvedRefMap = opts.resolvedRefMap ||
            (yield (0, resolve_1.resolveDocument)({
                rootDocument: document,
                rootType: types.ConfigRoot,
                externalRefResolver,
            }));
        (0, walk_1.walkDocument)({
            document,
            rootType: types.ConfigRoot,
            normalizedVisitors,
            resolvedRefMap,
            ctx,
        });
        return ctx.problems;
    });
}
exports.lintConfig = lintConfig;
