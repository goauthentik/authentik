"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentNameUnique = void 0;
const TYPE_NAME_SCHEMA = 'Schema';
const TYPE_NAME_PARAMETER = 'Parameter';
const TYPE_NAME_RESPONSE = 'Response';
const TYPE_NAME_REQUEST_BODY = 'RequestBody';
const TYPE_NAME_TO_OPTION_COMPONENT_NAME = {
    [TYPE_NAME_SCHEMA]: 'schemas',
    [TYPE_NAME_PARAMETER]: 'parameters',
    [TYPE_NAME_RESPONSE]: 'responses',
    [TYPE_NAME_REQUEST_BODY]: 'requestBodies',
};
const ComponentNameUnique = (options) => {
    const components = new Map();
    const typeNames = [];
    if (options.schemas !== 'off') {
        typeNames.push(TYPE_NAME_SCHEMA);
    }
    if (options.parameters !== 'off') {
        typeNames.push(TYPE_NAME_PARAMETER);
    }
    if (options.responses !== 'off') {
        typeNames.push(TYPE_NAME_RESPONSE);
    }
    if (options.requestBodies !== 'off') {
        typeNames.push(TYPE_NAME_REQUEST_BODY);
    }
    const rule = {
        ref: {
            leave(ref, { type, resolve }) {
                const typeName = type.name;
                if (typeNames.includes(typeName)) {
                    const resolvedRef = resolve(ref);
                    if (!resolvedRef.location)
                        return;
                    addComponentFromAbsoluteLocation(typeName, resolvedRef.location.absolutePointer.toString());
                }
            },
        },
        Root: {
            leave(root, ctx) {
                components.forEach((value, key, _) => {
                    if (value.size > 1) {
                        const component = getComponentFromKey(key);
                        const optionComponentName = getOptionComponentNameForTypeName(component.typeName);
                        const definitions = Array.from(value)
                            .map((v) => `- ${v}`)
                            .join('\n');
                        const problem = {
                            message: `Component '${optionComponentName}/${component.componentName}' is not unique. It is defined at:\n${definitions}`,
                        };
                        const componentSeverity = optionComponentName ? options[optionComponentName] : null;
                        if (componentSeverity) {
                            problem.forceSeverity = componentSeverity;
                        }
                        ctx.report(problem);
                    }
                });
            },
        },
    };
    if (options.schemas != 'off') {
        rule.NamedSchemas = {
            Schema(_, { location }) {
                addComponentFromAbsoluteLocation(TYPE_NAME_SCHEMA, location.absolutePointer.toString());
            },
        };
    }
    if (options.responses != 'off') {
        rule.NamedResponses = {
            Response(_, { location }) {
                addComponentFromAbsoluteLocation(TYPE_NAME_RESPONSE, location.absolutePointer.toString());
            },
        };
    }
    if (options.parameters != 'off') {
        rule.NamedParameters = {
            Parameter(_, { location }) {
                addComponentFromAbsoluteLocation(TYPE_NAME_PARAMETER, location.absolutePointer.toString());
            },
        };
    }
    if (options.requestBodies != 'off') {
        rule.NamedRequestBodies = {
            RequestBody(_, { location }) {
                addComponentFromAbsoluteLocation(TYPE_NAME_REQUEST_BODY, location.absolutePointer.toString());
            },
        };
    }
    return rule;
    function getComponentNameFromAbsoluteLocation(absoluteLocation) {
        const componentName = absoluteLocation.split('/').slice(-1)[0];
        if (componentName.endsWith('.yml') ||
            componentName.endsWith('.yaml') ||
            componentName.endsWith('.json')) {
            return componentName.slice(0, componentName.lastIndexOf('.'));
        }
        return componentName;
    }
    function addFoundComponent(typeName, componentName, absoluteLocation) {
        var _a;
        const key = getKeyForComponent(typeName, componentName);
        const locations = (_a = components.get(key)) !== null && _a !== void 0 ? _a : new Set();
        locations.add(absoluteLocation);
        components.set(key, locations);
    }
    function addComponentFromAbsoluteLocation(typeName, absoluteLocation) {
        const componentName = getComponentNameFromAbsoluteLocation(absoluteLocation);
        addFoundComponent(typeName, componentName, absoluteLocation);
    }
};
exports.ComponentNameUnique = ComponentNameUnique;
function getOptionComponentNameForTypeName(typeName) {
    var _a;
    return (_a = TYPE_NAME_TO_OPTION_COMPONENT_NAME[typeName]) !== null && _a !== void 0 ? _a : null;
}
function getKeyForComponent(typeName, componentName) {
    return `${typeName}/${componentName}`;
}
function getComponentFromKey(key) {
    const [typeName, componentName] = key.split('/');
    return { typeName, componentName };
}
