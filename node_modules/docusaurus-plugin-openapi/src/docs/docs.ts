/* ============================================================================
 * Copyright (c) Cloud Annotations
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * ========================================================================== */

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Taken and adapted from:
 * https://github.com/facebook/docusaurus/blob/main/packages/docusaurus-plugin-content-docs/src/docs.ts
 */

import path from "path";

import type {
  MetadataOptions,
  CategoryIndexMatcher,
  DocMetadataBase,
  DocFrontMatter,
} from "@docusaurus/plugin-content-docs";
import type { LoadContext } from "@docusaurus/types";
import {
  aliasedSitePath,
  normalizeUrl,
  parseMarkdownFile,
  DEFAULT_PARSE_FRONT_MATTER,
} from "@docusaurus/utils";

import { validateDocFrontMatter } from "./frontMatter";
import getSlug from "./slug";

type DocFile = {
  contentPath: string; // /!\ may be localized
  filePath: string; // /!\ may be localized
  source: string;
  content: string;
};

export type DocEnv = "production" | "development";

/** Docs with draft front matter are only considered draft in production. */
function isDraftForEnvironment({
  env,
  frontMatter,
}: {
  frontMatter: DocFrontMatter;
  env: DocEnv;
}): boolean {
  return (env === "production" && frontMatter.draft) ?? false;
}

async function doProcessDocMetadata({
  docFile,
  relativeSource,
  context,
  options,
  env,
}: {
  docFile: DocFile;
  relativeSource: string;
  context: LoadContext;
  options: Omit<
    MetadataOptions,
    | "editCurrentVersion"
    | "editLocalizedFiles"
    | "numberPrefixParser"
    | "breadcrumbs"
    | "showLastUpdateTime"
    | "showLastUpdateAuthor"
  >;
  env: DocEnv;
}): Promise<DocMetadataBase> {
  const { source, content, filePath } = docFile;
  const { siteDir } = context;

  const {
    frontMatter: parsedFrontMatter,
    contentTitle: parsedContentTitle,
    excerpt: parsedExcerpt,
  } = await parseMarkdownFile({
    fileContent: content,
    filePath,
    parseFrontMatter: DEFAULT_PARSE_FRONT_MATTER,
  });

  const frontMatter = validateDocFrontMatter(parsedFrontMatter);

  // E.g. api/plugins/myDoc -> myDoc; myDoc -> myDoc
  const sourceFileNameWithoutExtension = path.basename(
    source,
    path.extname(source)
  );

  // E.g. api/plugins/myDoc -> api/plugins; myDoc -> .
  const sourceDirName = path.dirname(source);

  const { filename: unprefixedFileName, numberPrefix } = {
    filename: sourceFileNameWithoutExtension,
    numberPrefix: undefined,
  };

  const baseID: string = frontMatter.id ?? unprefixedFileName;
  if (baseID.includes("/")) {
    throw new Error(`Document id "${baseID}" cannot include slash.`);
  }

  // For autogenerated sidebars, sidebar position can come from filename number
  // prefix or front matter
  const sidebarPosition: number | undefined =
    frontMatter.sidebar_position ?? numberPrefix;

  // TODO legacy retrocompatibility
  // I think it's bad to affect the front matter id with the dirname?
  function computeDirNameIdPrefix() {
    if (sourceDirName === ".") {
      return undefined;
    }
    return sourceDirName;
  }

  const id = [computeDirNameIdPrefix(), baseID].filter(Boolean).join("/");

  const docSlug = getSlug({
    baseID,
    source,
    sourceDirName,
    frontMatterSlug: frontMatter.slug,
  });

  // Note: the title is used by default for page title, sidebar label,
  // pagination buttons... frontMatter.title should be used in priority over
  // contentTitle (because it can contain markdown/JSX syntax)
  const title: string = frontMatter.title ?? parsedContentTitle ?? baseID;

  const description: string = frontMatter.description ?? parsedExcerpt ?? "";

  const permalink = normalizeUrl([
    context.baseUrl,
    options.routeBasePath,
    docSlug,
  ]);

  const draft = isDraftForEnvironment({ env, frontMatter });

  const unlisted = frontMatter.unlisted ?? false;

  // Assign all of object properties during instantiation (if possible) for
  // NodeJS optimization.
  // Adding properties to object after instantiation will cause hidden
  // class transitions.
  return {
    id,
    title,
    description,
    source: aliasedSitePath(filePath, siteDir),
    sourceDirName,
    slug: docSlug,
    permalink,
    draft,
    editUrl: null,
    tags: [],
    version: "",
    sidebarPosition,
    frontMatter,
    unlisted,
  };
}

export function processDocMetadata(args: {
  docFile: DocFile;
  relativeSource: string;
  context: LoadContext;
  options: Omit<
    MetadataOptions,
    | "editCurrentVersion"
    | "editLocalizedFiles"
    | "numberPrefixParser"
    | "breadcrumbs"
    | "showLastUpdateTime"
    | "showLastUpdateAuthor"
  >;
  env: DocEnv;
}): Promise<DocMetadataBase> {
  try {
    return doProcessDocMetadata(args);
  } catch (err) {
    console.error`Can't process doc metadata for doc at path path=${args.docFile.filePath}`;
    throw err;
  }
}

// By convention, Docusaurus considers some docs are "indexes":
// - index.md
// - readme.md
// - <folder>/<folder>.md
//
// This function is the default implementation of this convention
//
// Those index docs produce a different behavior
// - Slugs do not end with a weird "/index" suffix
// - Auto-generated sidebar categories link to them as intro
export const isCategoryIndex: CategoryIndexMatcher = ({
  fileName,
  directories,
}): boolean => {
  const eligibleDocIndexNames = [
    "index",
    "readme",
    directories[0]?.toLowerCase(),
  ];
  return eligibleDocIndexNames.includes(fileName.toLowerCase());
};

/**
 * `guides/sidebar/autogenerated.md` ->
 *   `'autogenerated', '.md', ['sidebar', 'guides']`
 */
export function toCategoryIndexMatcherParam({
  source,
  sourceDirName,
}: Pick<
  DocMetadataBase,
  "source" | "sourceDirName"
>): Parameters<CategoryIndexMatcher>[0] {
  // source + sourceDirName are always posix-style
  return {
    fileName: path.posix.parse(source).name,
    extension: path.posix.parse(source).ext,
    directories: sourceDirName.split(path.posix.sep).reverse(),
  };
}
