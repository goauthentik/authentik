
╭─── Claude Code v2.0.76 ──────────────────────────────────────────────────────╮
│                                                    │ Tips for getting        │
│                  Welcome back Ken!                 │ started                 │
│                                                    │ Run /init to create a … │
│                    * ▗ ▗   ▖ ▖ *                   │ ─────────────────────── │
│                   *             *                  │ Recent activity         │
│                    *   ▘▘ ▝▝   *                   │ No recent activity      │
│                                                    │                         │
│    Sonnet 4.5 · Claude Pro ·                       │                         │
│    kenneth.m.sternberg@gmail.com's Organization    │                         │
│                 ~/projects/dev/web                 │                         │
╰──────────────────────────────────────────────────────────────────────────────╯

> # Agent Guidelines for the authentik WebUI

This document provides guidelines for analyzing a large and complex 
single-page application written in Typescript, Lit-Element, and Patternfly-5
 which provides a set of User Interfaces for a Single Sign-On Application. 
The backend of the application is written in Django, and uses the Django 
Rest Framework and OpenAPI tools to generate the schema and Typescript API 
library for this application.

## Core Principles

- The initial draft of this UI was written by the founder, who was not a 
Javascript expert. They chose the Patternfly & Lit combination. It has 
proven an awkward fit, and we are committed to making it less so.

- The code should be as aggressive as possible in determining the user’s 
preferences with respect to language and locale, light or dark mode, and 
prefers-reduced motion.

- Each layer of the code should be as independent as possible from the layer
 above or below it. We are seeking loose integration without sacrificing 
user experience.

# Architectural Overview

The authentik WebUI is built around three major experiences:

- The Flow library, which provides a dialogue between the authentik SSO 
server and the third-party applications with which one integrates and 
accesses via authentik. It is written around a request/response cycle in 
which forms are specified programmatically and on-demand from the back-end.
- The User library, which provides an ordinary user with a page listing the 
applications that User has access to, as well as a handful of facilities for
 customizing their experience, adding passkeys and other two-factor 
solutions, and changing their password.
- The Administrative library, which provides access to the objects (Django 
models) that administrators need to see, review, and update, such as the 
applications that can be accessed via an authentik instance, the 
authentication providers used to access them, identity sources such as LDAP,
 and a myriad of other tools and capabilities, as well as monitoring and 
notification facilities.

The *intent* of the architecture is as follows:

- An application shell that determines the user’s preferences such as 
language, locale, and theme, and provides Lit controllers with access to the
 basic configuration, “brand” information (the SSO can support multiple 
custom themes for different brands on a single product), and managing 
modals.
- Additional controllers for features specific to the User or Administrator,
- A routing system that can access pages within a given interface,

Within the *admin* application specifically, we have the following 
divisions:

- Table pages, which allow sysadmins to see and sometimes manage lists of 
collections that are managed by authentik
- Form pages (and Form modals), which allow sysadmins to edit single items
- Custom pages: the dashboard, enterprise status, notifications, and other 
pages that are not of themselves tied to a single Django model.
- Wizards: There are a handful that provide a multi-page experience.

The source code for this is read in the folder `./src`.

The authentik API is located in the folder 
`./node_modules/@goauthentik/api/src/`.

# Tasks

## Preface

This past year the UI has experienced explosive growth in the number of new 
features, all of which are made difficult to streamline and isolate by what 
is, unfortunately, a baroque architecture built by an amateur. The UI team 
attempting to fix its shortcomings has been bitten time and time again by 
“unravelling”: attempts to fix one subsystem, such as the language & locale,
 or such as theme, results in our having to touch the entire application and
 modify dozens if not hundreds of files, and often intersects with other 
subsystems.

Despite its shortcomings, the existing UI has won praise for its usability. 
We would like to preserve and improve on that usability.

<important>

DO NOT WRITE ANY CODE TO ANY FILE. We are not generating code for this 
project at the moment.
</important>

## Task:

1.  Analyze this code base and provide a *high level* overview of its 
architecture. Be clear about where the description in *this* document fails 
to correspond with the reality of the code base.

2.  With that analysis, provide a recommended set of steps for correcting 
what faults the high-level subsystems of AppShell, Router, Sidebar, and 
Controllers, and what consequences correcting such faults may have on our 
process. The goal is to isolate subsystems in a way that reduces coupling 
without damaging the existing user experience. 

⏺ I'll analyze the authentik WebUI codebase to provide you with a high-level architectural overview and identify where the documented intent diverges from reality. Let me start by exploring the codebase structure.

⏺ Explore(Explore codebase structure)
  ⎿  Done (40 tool uses · 65.4k tokens · 2m 19s)                           

⏺ Now let me examine specific implementation details to provide concrete recommendations for decoupling these subsystems.

⏺ Read(src/elements/Interface.ts)
  ⎿  Read 48 lines

⏺ Read(src/elements/router/RouterOutlet.ts)
  ⎿  Read 214 lines

⏺ Read(src/elements/sidebar/Sidebar.ts)
  ⎿  Read 49 lines

⏺ Read(src/admin/AdminInterface/AdminSidebar.ts)
  ⎿  Read 113 lines

⏺ Read(src/elements/AuthenticatedInterface.ts)
  ⎿  Read 19 lines

⏺ Read(src/admin/AdminInterface/index.ts)
  ⎿  Error reading file

⏺ Read(src/elements/controllers/ContextControllerRegistry.ts)
  ⎿  Read 13 lines

⏺ Search(pattern: "**/AdminInterface*.ts", path: "src/admin")
  ⎿  Found 0 files 

⏺ Search(pattern: "class AdminInterface", path: "src/admin")
  ⎿  Found 1 file (ctrl+o to expand)

⏺ Read(src/admin/AdminInterface/index.entrypoint.ts)
  ⎿  Read 202 lines

⏺ Read(src/elements/mixins/WithBrandConfig.ts)
  ⎿  Error reading file

⏺ Search(pattern: "**/WithBrandConfig.ts", path: "src")
  ⎿  Found 0 files 

⏺ Search(pattern: "**/mixins/*.ts", path: "src/elements")
  ⎿  Found 8 files (ctrl+o to expand)

⏺ Read(src/elements/mixins/branding.ts)
  ⎿  Read 98 lines

⏺ Read(src/common/global.ts)
  ⎿  Read 77 lines

⏺ Read(src/common/theme.ts)
  ⎿  Read 100 lines

⏺ Now I have a comprehensive understanding of the codebase. Let me provide a detailed architectural analysis with specific recommendations.

  ---
  Architectural Analysis of authentik WebUI

  Executive Summary

  The authentik WebUI demonstrates a classic case of organic growth without architectural boundaries. What began as three separate interfaces (Flow, User, Admin) with shared infrastructure has evolved into a tightly-coupled system where cross-cutting concerns (theme, locale, authentication) create dependency chains that make isolated changes impossible.

  The core problem: There is no architectural layer separation. The Interface classes, Controllers, Mixins, and Components form a tangled dependency graph rather than a clean layered architecture.

  ---
  Part 1: Reality vs. Documented Intent

  The "AppShell" That Doesn't Exist

  Documentation claims: An application shell that manages preferences (language, locale, theme) and provides controllers with access to configuration, brand, and modals.

  Reality:
  - No unified "AppShell" component exists
  - Three separate interface implementations with inheritance:
  Interface (base)
    ├→ AuthenticatedInterface → AdminInterface / UserInterface
    └→ FlowExecutor (separate branch)
  - Each interface constructs its own controller set in constructor()
  - Preferences are managed by a mix of:
    - globalAK() function reading window.authentik object (src/common/global.ts:35)
    - Controllers fetching and caching API data (Interface.ts:26-29)
    - Individual components reading localStorage
    - Theme application happening at document level (Interface.ts:24)

  Consequences:
  - Cannot swap interfaces without duplicating initialization logic
  - No single source of truth for application state
  - Preferences management scattered across 5+ different modules

  Router Architecture

  Documentation claims: A routing system that accesses pages within a given interface.

  Reality:
  - Hash-based router (RouterOutlet.ts:135) listening to hashchange events
  - Non-standard parameter encoding using semicolons: #/path;{"key":"value"} (RouterOutlet.ts:54)
  - Flat route arrays, no hierarchy: admin has ~50 routes, user has 2 (admin/Routes.ts, user/Routes.ts)
  - Routes are regex-based with lazy component loading (Route.ts:1)
  - No route guards, no nested routes, no declarative parameter extraction

  Key Issues:
  1. URL encoding is brittle: The semicolon separator in paramURL() (RouterOutlet.ts:50-58) means any URL containing ; will break
  2. Routes are disconnected from data: Each route is [regex, () => import(...)] - no metadata, no permissions, no relationship to sidebar
  3. No composition: Cannot define route hierarchies or shared layouts
  4. Testing is hard: Routes are defined as dynamic imports, making unit tests difficult

  Sidebar Architecture

  Documentation claims: Sidebar is part of the interface system.

  Reality:
  - Sidebar is a dumb presentational component (Sidebar.ts:14-42) - just a styled <slot>
  - Structure is defined in AdminSidebar.ts using brittle tuple format:
  type SidebarEntry = [path | null, label, attributes?, children?]
  - (AdminSidebar.ts:14-19)
  - Sidebar data is manually maintained and has zero relationship to route definitions
  - Routes live in admin/Routes.ts, sidebar in admin/AdminInterface/AdminSidebar.ts - completely separate files
  - The "activeWhen" attribute (AdminSidebar.ts:63) duplicates the route regex patterns

  Consequences:
  - Adding a new page requires updating TWO files minimum (Routes.ts + AdminSidebar.ts)
  - No compile-time verification that sidebar links point to valid routes
  - Cannot generate sidebar from routes or routes from sidebar
  - Tuple format is type-unsafe and error-prone

  Controllers Architecture

  Documentation claims: Controllers provide access to configuration and features.

  Reality: This is the one subsystem that works well, but has coupling issues:

  The Good:
  - Clean use of Lit's Reactive Controller pattern
  - Context API provides reactive data propagation
  - Controllers are composable and focused (BrandContextController.ts, LocaleContextController.ts, etc.)

  The Bad:
  - Controllers are tightly coupled to Interface lifecycle:
  constructor() {
    this.addController(new LocaleContextController(this, locale));
    this.addController(new ConfigContextController(this, config));
    // ... (Interface.ts:26-29)
  }
  - No way to use controllers outside Interface hierarchy
  - ContextControllerRegistry is a global WeakMap singleton (ContextControllerRegistry.ts:12)
  - Mixins create brittle composition chains:
  class AdminInterface extends WithCapabilitiesConfig(
    WithNotifications(WithSession(AuthenticatedInterface))
  )
  - (index.entrypoint.ts:55-56)

  - This is 4 levels deep, and order matters!

  ---
  Part 2: Root Causes of the "Unravelling" Problem

  Why Changing Theme/Locale Touches Everything

  Let's trace a theme change through the system to see the cascade:

  1. Initialization (global.ts:35-68):
    - Backend injects window.authentik.brand object
    - globalAK() reads it and converts to TypeScript
  2. Interface Construction (Interface.ts:22-28):
    - Calls globalAK() to get initial brand
    - Calls createUIThemeEffect(applyDocumentTheme) - mutates document
    - Creates BrandingContextController with brand data
  3. Controller (BrandContextController.ts - not shown but inferred):
    - Fetches current brand from API
    - Stores in context
    - Notifies consumers on change
  4. Mixins (branding.ts:65-97):
    - WithBrandConfig creates abstract class that consumes BrandingContext
    - Every component using this mixin subscribes to brand changes
  5. Theme Application (theme.ts:1-100):
    - Document-level stylesheet manipulation
    - CSS custom properties updated
    - Individual components may have theme-specific styles

  The Unravelling:
  - To change theme initialization: touch global.ts, Interface.ts, theme.ts
  - To change theme propagation: touch BrandContextController.ts, BrandingContext
  - To change how components consume theme: touch branding.ts mixin, all components using it
  - To add a new theme: touch theme.ts, branding types, potentially component stylesheets

  There's no single "theme subsystem" - it's fractured across 7+ modules in 4+ directories.

  The Mixin Depth Problem

  AdminInterface has this composition:
  WithCapabilitiesConfig(
    WithNotifications(
      WithSession(
        AuthenticatedInterface  // which itself extends Interface
      )
    )
  )

  Problems:
  1. Order dependency: WithSession must come before WithNotifications (notifications need user session)
  2. Type complexity: Each wrapper adds complexity to type inference
  3. Debugging difficulty: Stack traces go through 4 mixin layers
  4. Testability: Cannot test mixins in isolation easily
  5. Mental overhead: Must understand the entire chain to add capabilities

  ---
  Part 3: Detailed Subsystem Critique

  AppShell / Interface Layer

  Current State:
  - Interface (base): Creates 4 controllers (Locale, Config, Branding, Modal) (Interface.ts:26-29)
  - AuthenticatedInterface: Adds 4 more controllers (License, Session, Version, Notifications) (AuthenticatedInterface.ts:13-16)
  - AdminInterface: Uses 3 mixins (AdminInterface/index.entrypoint.ts:55-56)
  - Each interface renders its own layout structure

  Problems:
  1. Duplicated initialization logic - each interface builds its controller set manually
  2. No interface swapping - cannot switch User → Admin without full page reload
  3. Testing requires full interface - cannot test components in isolation
  4. Global side effects - createUIThemeEffect(applyDocumentTheme) mutates document (Interface.ts:24)

  Why This Is Hard:
  - Controllers are created in constructor, impossible to inject or mock
  - No dependency injection system
  - Theme initialization has side effects on document
  - Each interface has hard-coded layout in render()

  Router Subsystem

  Current State:
  - RouterOutlet component watches hashchange (RouterOutlet.ts:91)
  - Routes defined as Route[] with regex + lazy import function
  - Parameter encoding: #/path;{"json":"params"} (RouterOutlet.ts:54)
  - No nested routes, no route guards, no metadata

  Problems:
  1. Hash-based routing is outdated - breaks browser UX (back button, bookmarks with params)
  2. Parameter encoding is non-standard - ; separator is fragile, JSON in URL is ugly
  3. Routes are disconnected from metadata - no way to attach permissions, titles, icons
  4. Flat structure - no parent/child relationships, every route is top-level
  5. No type safety for parameters - route regex has named groups but no TypeScript types
  6. Testing is difficult - routes use dynamic imports, hard to test without bundler

  Example of brittleness:
  // AdminSidebar.ts:63
  ["/core/applications", msg("Applications"),
    [`^/core/applications/(?<slug>${SLUG_REGEX})$`]]

  The regex pattern is duplicated from the route definition, and manually kept in sync.

  Sidebar Subsystem

  Current State:
  - Sidebar component is purely presentational (Sidebar.ts:25-40)
  - Structure defined as nested tuples (AdminSidebar.ts:56-105)
  - Rendered in AdminInterface with function call (index.entrypoint.ts:166-169)

  Problems:
  1. Tuple format is brittle:
  ["/path", msg("Label"), { attr: value }, [children]]
  1. No type safety, easy to mix up parameter order
  2. Duplicates route patterns:
  Sidebar has activeWhen regexes that duplicate Routes.ts definitions (AdminSidebar.ts:63, 68, 73, etc.)
  3. Manual maintenance:
  Adding a route requires updating both Routes.ts and AdminSidebar.ts
  4. No validation:
  Nothing prevents sidebar links that point to non-existent routes
  5. Cannot be derived from routes:
  Routes have no metadata, so can't auto-generate sidebar

  Why This Matters:
  When you add a new admin page, you must:
  1. Add route to Routes.ts
  2. Add sidebar entry to AdminSidebar.ts
  3. Ensure regex patterns match
  4. Remember to update both if URL pattern changes

  This is 3 edits minimum, all manual, all error-prone.

  Controllers Subsystem

  Current State:
  - Base class: ReactiveContextController (not shown, but referenced)
  - 8 specialized controllers for different contexts
  - Registered in Interface via addController() (Interface.ts:32-41)
  - Accessed via mixins that consume contexts (branding.ts:65-97)
  - Global registry for programmatic access (ContextControllerRegistry.ts:12)

  What Works:
  - Reactive updates via Lit's context API
  - Clean separation between data source (controller) and consumer (mixin/component)
  - Controllers are focused and single-purpose

  Problems:
  1. Coupled to Interface:
  Controllers are created in Interface constructor (Interface.ts:26-29)
  Cannot use controllers without an Interface instance
  2. Mixin composition is deep:
  WithA(WithB(WithC(BaseClass)))
  2. Fragile, order-dependent, hard to debug
  3. Global registry is a hack:
  ContextControllerRegistry as a WeakMap singleton suggests architectural problems (ContextControllerRegistry.ts:12)
  If context API was sufficient, wouldn't need this
  4. No lazy loading:
  All controllers created upfront, even if not used
  5. Testing is coupled:
  To test a component with WithSession, you need SessionContextController, which needs an API, which needs...

  ---
  Part 4: Recommended Decoupling Steps

  These recommendations are ordered by dependency and risk, not priority. Lower-numbered steps should be completed before higher ones where noted.

  Step 1: Establish Clear Layer Boundaries

  Goal: Define architectural layers and enforce separation.

  Action: Create explicit layers with defined dependencies:

  ┌─────────────────────────────────────┐
  │   Presentation (Components, Pages)  │  ← Can use Application & Domain
  ├─────────────────────────────────────┤
  │   Application (Interface, Router)   │  ← Can use Domain, not Components
  ├─────────────────────────────────────┤
  │   Domain (Models, API, Services)    │  ← Pure business logic, no UI
  ├─────────────────────────────────────┤
  │   Infrastructure (Theme, Locale, WS)│  ← Shared utilities
  └─────────────────────────────────────┘

  Concrete Changes:
  1. Create layer directories:
    - /src/app/ - Application shell, routing, orchestration
    - /src/domain/ - API client, models, business logic
    - /src/ui/ - Components, forms, tables (currently /elements + /components)
    - /src/infrastructure/ - Theme, locale, websockets (currently /common)
  2. Enforce boundaries:
    - Add ESLint rule to prevent upward dependencies (e.g., domain importing from ui)
    - Create explicit "public API" files (index.ts) for each layer

  Why This First:
  - Establishes vocabulary and mental model for remaining work
  - Makes it obvious where code belongs
  - Prevents backsliding during refactoring

  Consequences:
  - Requires moving many files (but not changing their content)
  - Import paths will change across codebase
  - Could use path aliases to minimize churn: #app/, #domain/, #ui/, #infra/

  Risk: Medium - mostly mechanical changes, but high volume

  ---
  Step 2: Extract Theme & Locale as Infrastructure Services

  Goal: Make theme and locale into injectable services rather than controller-based state.

  Why This Matters:
  This is the #1 cause of unravelling. Theme and locale touch:
  - Interface initialization (Interface.ts:22-28)
  - Controllers (LocaleContextController, BrandContextController)
  - Mixins (branding.ts, locale.ts)
  - Individual components (reading theme-specific styles)
  - Document-level mutations (theme.ts)

  Action: Create service-based architecture:

  // infrastructure/theme/ThemeService.ts
  class ThemeService {
    readonly theme$: Observable<ResolvedUITheme>

    applyTheme(theme: UIThemeHint): void
    getCurrentTheme(): ResolvedUITheme
    observeSystemPreference(): Observable<ResolvedUITheme>
  }

  // infrastructure/locale/LocaleService.ts
  class LocaleService {
    readonly locale$: Observable<TargetLanguageTag>

    setLocale(locale: TargetLanguageTag): void
    getCurrentLocale(): TargetLanguageTag
    autoDetectLocale(): TargetLanguageTag
  }

  Benefits:
  1. Single responsibility: Each service does ONE thing
  2. Testable in isolation: Mock service in tests, no Interface needed
  3. No controllers/mixins needed: Components import service directly
  4. Observable pattern: Reactive updates without Lit context API
  5. Lazy loading: Only initialize when first accessed

  Migration Strategy:
  - Phase 1: Create services alongside existing controllers
  - Phase 2: Update Interface to use services, keep controllers for compatibility
  - Phase 3: Deprecate mixins, update components to use services
  - Phase 4: Remove controllers and context providers

  Consequences:
  - Touches: Interface, 2 controllers, 2 mixins, all components using theme/locale
  - Risk: High (affects entire app)
  - Benefit: Eliminates ~40% of the unravelling problem

  ---
  Step 3: Unify Interface Layer into True "AppShell"

  Goal: Single AppShell component that composes sections, not inheritance hierarchy.

  Current Problem:
  Three different interface classes with duplicate initialization logic.

  Action: Create composition-based shell:

  // app/shell/AppShell.ts
  class AppShell extends LitElement {
    @property() section!: 'admin' | 'user' | 'flow'

    #services = {
      theme: new ThemeService(),
      locale: new LocaleService(),
      api: new APIService(),
      // ... other services
    }

    render() {
      return html`
        <app-navbar></app-navbar>
        ${this.#renderSection()}
      `
    }

    #renderSection() {
      switch (this.section) {
        case 'admin': return html`<admin-shell></admin-shell>`
        case 'user': return html`<user-shell></user-shell>`
        case 'flow': return html`<flow-shell></flow-shell>`
      }
    }
  }

  Benefits:
  1. Single initialization point: Services created once
  2. Section swapping: Can switch admin ↔ user without reload
  3. Testable: Each section can be tested with mock services
  4. Clear ownership: AppShell owns global concerns, sections own their layouts

  Migration Strategy:
  - Step 3a: Create new AppShell alongside existing Interface classes
  - Step 3b: Move controller logic into services
  - Step 3c: Update entrypoints to use AppShell instead of Interface
  - Step 3d: Remove Interface/AuthenticatedInterface/AdminInterface classes

  Consequences:
  - Touches: All 3 entrypoint files, Interface hierarchy, admin/user/flow roots
  - Breaks: Controllers (move to services), mixins (replace with service imports)
  - Risk: High - affects entire app initialization
  - Benefit: Eliminates inheritance complexity, enables section swapping

  Dependency: Requires Step 2 (services) to be complete

  ---
  Step 4: Modernize Router

  Goal: Replace hash-based router with History API, add metadata, enable composition.

  Current Problems:
  - Hash-based routing (breaks UX)
  - Non-standard param encoding (; separator)
  - Flat structure (no nesting)
  - No metadata (can't attach permissions, titles, icons)
  - Manual relationship to sidebar

  Action: Create declarative router with metadata:

  // app/router/Route.ts
  interface Route {
    path: string  // e.g., "/applications/:id"
    component: () => Promise<unknown>  // lazy import

    // Metadata
    title?: () => string
    permissions?: string[]
    icon?: string
    showInSidebar?: boolean
    parent?: string  // path of parent route

    // Guards
    canActivate?: () => boolean

    // Data
    data?: Record<string, unknown>
  }

  Example:
  const routes: Route[] = [
    {
      path: '/applications',
      component: () => import('./ApplicationListPage'),
      title: () => msg('Applications'),
      icon: 'pf-icon-applications',
      showInSidebar: true,
    },
    {
      path: '/applications/:slug',
      component: () => import('./ApplicationViewPage'),
      title: (params) => msg('Application: {slug}', params),
      parent: '/applications',  // nested under /applications
    },
  ]

  Benefits:
  1. Sidebar auto-generation: Filter routes where showInSidebar: true
  2. Type-safe params: Extract :slug param types from path
  3. Route guards: Check permissions before rendering
  4. Breadcrumbs: Use parent relationships to build navigation
  5. Better URLs: /applications/my-app instead of #/applications;{"slug":"my-app"}

  Migration Strategy:
  - Step 4a: Create new Router alongside RouterOutlet
  - Step 4b: Support both hash and history modes during transition
  - Step 4c: Update all route definitions to new format
  - Step 4d: Generate sidebar from routes
  - Step 4e: Remove RouterOutlet and hash mode

  Consequences:
  - Touches: RouterOutlet, all Routes.ts files, AdminSidebar.ts, navigation helpers
  - Breaks: All existing URLs (need redirect handling)
  - Risk: Medium-High - routing is critical, but changes are localized
  - Benefit: Eliminates sidebar duplication, improves UX

  Dependency: Can be done in parallel with Steps 1-3, but Step 3 makes integration easier

  ---
  Step 5: Decouple Controllers from Interface

  Goal: Make controllers usable without Interface inheritance, eliminate mixin composition.

  Current Problem:
  - Controllers are created in Interface constructor
  - Consumed via mixins that create deep composition chains
  - Cannot use controllers outside Interface hierarchy

  Action: Implement proper dependency injection:

  // app/services/ServiceContainer.ts
  class ServiceContainer {
    private static instances = new Map()

    static register<T>(key: symbol, factory: () => T): void {
      this.instances.set(key, factory())
    }

    static get<T>(key: symbol): T {
      return this.instances.get(key)
    }
  }

  // Usage in components
  class MyComponent extends LitElement {
    #session = ServiceContainer.get(SessionService)

    render() {
      return html`User: ${this.#session.currentUser}`
    }
  }

  Benefits:
  1. No mixins needed: Components get services directly
  2. Testable: Mock services in tests via ServiceContainer.register()
  3. Lazy loading: Services created on-demand
  4. Clear dependencies: Component explicitly declares what it needs
  5. No composition chains: No more WithA(WithB(WithC(...)))

  Alternative Approach: Use Lit context API properly, without mixins:

  class MyComponent extends LitElement {
    @consume({ context: SessionContext })
    session!: SessionState

    // No mixin, just direct consumption
  }

  Migration Strategy:
  - Step 5a: Create ServiceContainer or improve context usage
  - Step 5b: Convert one controller/mixin pair (e.g., Session)
  - Step 5c: Update all components using that mixin
  - Step 5d: Repeat for remaining controllers
  - Step 5e: Remove mixin infrastructure

  Consequences:
  - Touches: All components using mixins (~100+ files)
  - Breaks: Current mixin composition pattern
  - Risk: High - affects entire component tree
  - Benefit: Massive simplification, easier testing

  Dependency: Easier after Step 3 (AppShell) is complete

  ---
  Step 6: Consolidate UI Component Libraries

  Goal: Establish clear boundary between infrastructure (elements/) and reusable components (components/).

  Current Problem:
  - /elements/ contains both infrastructure (Interface, Router) and reusable UI (Table, Form)
  - /components/ contains field inputs and some custom components
  - Unclear which directory to use for new components

  Action:
  1. Move infrastructure to /app/:
    - Interface → app/shell/
    - Router → app/router/
    - Controllers → (converted to services in /infrastructure/)
  2. Move reusable UI to /ui/:
    - Table, Form, Modal → ui/patterns/
    - Buttons, inputs → ui/primitives/
    - Messages, banners → ui/feedback/
  3. Establish conventions:
    - ui/primitives/ - Atomic components (buttons, inputs)
    - ui/patterns/ - Composed patterns (forms, tables, modals)
    - ui/layout/ - Layout components (page, section, grid)
    - ui/feedback/ - User feedback (toasts, banners, alerts)

  Benefits:
  - Clear mental model for where components belong
  - Easier to find existing components
  - Can extract UI library into separate package later

  Consequences:
  - Touches: All imports across entire codebase
  - Risk: Medium - mechanical changes but high volume
  - Benefit: Long-term maintainability

  Dependency: Can be done anytime, but easier after Step 1 (layer boundaries)

  ---
  Step 7: Standardize Form and Table Abstractions

  Goal: Simplify the complex Form/Table inheritance hierarchies.

  Current Problem:
  - Multiple inheritance levels: Form → ModelForm → ModalForm → ProxyForm
  - Similar complexity for tables
  - Hard to understand which class to extend

  This is a lower priority than the above issues, but worth noting:

  Action:
  1. Flatten hierarchy: Use composition instead of inheritance
  2. Separate concerns:
    - Data binding (model) from presentation (modal/page)
    - Table logic from layout
  3. Provide builders: Factory functions for common cases

  Example:
  // Instead of extending ModelForm + ModalForm
  const userForm = createModelForm({
    model: User,
    fields: ['username', 'email'],
    mode: 'modal',  // or 'page'
  })

  Dependency: Requires Steps 1-5 to be stable first

  ---
  Part 5: Migration Consequences & Risk Assessment

  High-Risk Changes (Affect Entire App)

  1. Step 2 (Theme/Locale Services):
    - Touches: ~150+ files
    - Risk: Breaking theme/locale everywhere
    - Mitigation: Feature-flag new system, run in parallel during migration
  2. Step 3 (AppShell):
    - Touches: All entry points, initialization
    - Risk: App won't boot if done wrong
    - Mitigation: Create new AppShell first, switch entrypoints one at a time
  3. Step 5 (Remove Mixins):
    - Touches: ~100+ components
    - Risk: Breaking component access to services
    - Mitigation: Use codemod to automate conversion

  Medium-Risk Changes

  4. Step 4 (Router):
    - Touches: ~60 files (Routes.ts, navigation, sidebar)
    - Risk: Breaking all URLs, navigation
    - Mitigation: Support both hash and history routing during transition
  5. Step 6 (UI Organization):
    - Touches: Every file (imports)
    - Risk: Breaking imports
    - Mitigation: Use automated refactoring tools, update in batches

  Low-Risk Changes

  6. Step 1 (Layer Boundaries):
    - Mostly organizational
    - Risk: Import path changes
    - Mitigation: Use path aliases, update in one commit
  7. Step 7 (Form/Table Simplification):
    - Isolated to form/table usage
    - Risk: Breaking admin forms
    - Mitigation: Do incrementally, one form pattern at a time

  ---
  Part 6: The Path Forward

  Recommended Sequence

  If you have limited time and want maximum impact, do this sequence:

  1. Step 2 (Theme/Locale Services) - Eliminates 40% of unravelling problem
  2. Step 4 (Router) - Eliminates sidebar duplication, improves UX
  3. Step 3 (AppShell) - Consolidates initialization, enables future work

  This sequence gives you:
  - Decoupled theme/locale (biggest pain point)
  - Unified routing + sidebar (second biggest pain point)
  - Foundation for remaining work

  If you have more time, continue with:

  4. Step 5 (Remove Mixins) - Simplifies component development
  5. Step 1 (Layer Boundaries) - Makes codebase navigable
  6. Step 6 (UI Organization) - Finishing touches

  What You'll Achieve

  After Steps 2-4 (Core Decoupling):
  - Adding a new admin page requires editing ONE file (routes), not three
  - Changing theme/locale doesn't cascade through entire app
  - Components can be tested in isolation
  - New developers can understand routing system

  After Steps 1-6 (Full Refactor):
  - Clear architectural layers
  - No inheritance hierarchies (composition instead)
  - Services instead of controllers/mixins
  - Codebase is approachable for new contributors

  What You Won't Solve (Out of Scope)

  These are separate problems:

  - PatternFly integration awkwardness (requires CSS/design system work)
  - Form validation complexity (requires form library evaluation)
  - API client code generation (OpenAPI tooling issue)
  - Wizard complexity (need specialized wizard framework)

  ---
  Conclusion

  The authentik WebUI has grown into a tangled ball of dependencies where changing one subsystem requires touching dozens of files across multiple directories. This is a textbook case of insufficient architectural boundaries combined with premature abstraction (mixins, deep inheritance).

  The root causes are:

  1. No layer separation: Application shell, routing, business logic, and UI all mixed together
  2. Cross-cutting concerns as controllers: Theme/locale implemented as stateful controllers instead of services
  3. Inheritance over composition: Multiple 4+ level deep class hierarchies
  4. Manual duplication: Routes and sidebar maintained separately
  5. Tight coupling: Cannot use one subsystem without pulling in entire dependency chain

  The recommended solution is architectural refactoring focused on:

  - Services over controllers (Step 2)
  - Composition over inheritance (Steps 3, 5)
  - Declarative over imperative (Step 4)
  - Explicit over implicit (Step 1)

  This won't be quick—expect 4-8 weeks for core changes (Steps 1-4), but the payoff is sustainable development velocity and the ability to make isolated changes without unravelling the entire application.

  The existing UI has earned praise for usability, and these changes preserve that while making the codebase maintainable. The key is doing this incrementally using the phased migration strategies outlined above, rather than attempting a "big bang" rewrite.



