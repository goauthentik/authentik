import type { PropSidebarItem } from "@docusaurus/plugin-content-docs";

/**
 * Difficulty levels for learning resources
 */
export const DIFFICULTY_LEVELS = ["beginner", "intermediate", "advanced"] as const;
export type DifficultyLevel = (typeof DIFFICULTY_LEVELS)[number];

/**
 * Types of learning resources
 */
export const RESOURCE_TYPES = ["tutorial", "guide", "reference", "video", "example"] as const;
export type ResourceType = (typeof RESOURCE_TYPES)[number];

/**
 * Standardized resource interface used by LearningCenterHelper and DocCardList
 */
export interface LearningCenterResource {
    id: string;
    resourceName: string;
    category: string;
    learningPaths: string[];
    shortDescription: string;
    longDescription?: string;
    difficulty: DifficultyLevel;
    resourceType: ResourceType;
    estimatedTime?: string;
    prerequisites?: string[];
    relatedResources?: string[];
}

export interface LearningCenterFilterCriteria {
    query?: string;
    selectedCategories?: readonly string[];
    selectedDifficulty?: DifficultyLevel | null;
    selectedLearningPath?: string | null;
}

/**
 * Determines if the current path is within the learning center section
 */
export function isLearningCenterPath(pathname: string): boolean {
    return /\/learning-center(\/|$)/.test(pathname);
}

function isLearningCenterIndexDocId(docId: string): boolean {
    return docId.endsWith("learning-center/index") || docId === "core/learning-center/index";
}

function isLearningCenterPathDocId(docId: string): boolean {
    return docId.includes("/learning-center/path/") || docId.includes("/learning-center/paths/");
}

function isLearningCenterIndexHref(href: string): boolean {
    return href.endsWith("/learning-center") || href.endsWith("/learning-center/");
}

function isLearningCenterPathHref(href: string): boolean {
    return href.includes("/learning-center/path/") || href.includes("/learning-center/paths/");
}

/**
 * Determines if a sidebar item is a learning center article (leaf item only).
 * This is used for resource extraction in DocCardList.
 */
export function isLearningCenterItem(item: PropSidebarItem): boolean {
    // Only check link items
    if (item.type !== "link") {
        return false;
    }

    // Check if it's a link with docId containing 'learning-center' (but not the index)
    if ("docId" in item) {
        const docId = item.docId || "";
        if (
            docId.includes("learning-center") &&
            !isLearningCenterIndexDocId(docId) &&
            !isLearningCenterPathDocId(docId)
        ) {
            return true;
        }
    }

    // Check if it's a link with href containing '/learning-center/' (but not the index)
    if ("href" in item) {
        const href = item.href || "";
        if (
            href.includes("/learning-center/") &&
            !isLearningCenterPathHref(href) &&
            !isLearningCenterIndexHref(href)
        ) {
            return true;
        }
    }

    return false;
}

/**
 * Checks if a category is the top-level Learning Center category (links to index)
 */
function isLearningCenterMainCategory(item: PropSidebarItem): boolean {
    if (item.type !== "category") return false;

    // Check if this category has a link to the learning center index
    if ("link" in item && item.link) {
        const link = item.link as { type?: string; id?: string };
        if (link.type === "doc" && link.id) {
            // Check if the link ID ends with learning-center/index
            if (isLearningCenterIndexDocId(link.id)) {
                return true;
            }
        }
    }

    // Fallback: check if the label is "Learning Center" (from autogenerated)
    if ("label" in item && item.label === "Learning Center") {
        return true;
    }

    return false;
}

/**
 * Determines if a sidebar item should be filtered from the sidebar navigation.
 * This filters:
 * - Learning center article links (leaf items)
 * - Learning center sub-categories (category-a, category-b, etc.)
 * But NOT the main Learning Center link/category itself.
 */
export function shouldFilterFromSidebar(item: PropSidebarItem): boolean {
    // Never filter the main Learning Center category (the one with index link)
    if (isLearningCenterMainCategory(item)) {
        return false;
    }

    // Filter learning center article links
    if (item.type === "link") {
        if ("docId" in item) {
            const docId = item.docId || "";
            // Filter articles within learning-center sub-directories (e.g., learning-center/category-a/article-a)
            // but NOT the index (learning-center/index)
            if (docId.includes("learning-center/") && !isLearningCenterIndexDocId(docId)) {
                return true;
            }
        }
        if ("href" in item) {
            const href = item.href || "";
            // Filter links that go deeper into learning-center (e.g., /learning-center/category-a/...)
            const pathParts = href.split("/").filter(Boolean);
            const lcIndex = pathParts.indexOf("learning-center");
            // If there are parts after "learning-center" (sub-paths), filter it
            if (lcIndex >= 0 && pathParts.length > lcIndex + 1) {
                return true;
            }
        }
    }

    // Filter learning center sub-categories (category-a, category-b, etc.)
    if (item.type === "category" && "items" in item && Array.isArray(item.items)) {
        // Check if ALL children are learning center items - if so, this is a LC sub-category
        const hasOnlyLcItems =
            item.items.length > 0 &&
            item.items.every((child) => {
                if (child.type === "link") {
                    return shouldFilterFromSidebar(child);
                }
                if (child.type === "category") {
                    return shouldFilterFromSidebar(child);
                }
                return false;
            });
        if (hasOnlyLcItems) {
            return true;
        }
    }

    return false;
}

/**
 * Safely extracts string value from potentially undefined/mixed-type object property
 */
export function safeStringExtract(value: unknown, fallback: string = ""): string {
    return typeof value === "string" && value.trim().length > 0 ? value : fallback;
}

/**
 * Safely extracts string array from potentially undefined/mixed-type object property
 */
export function safeStringArrayExtract(value: unknown): string[] {
    return Array.isArray(value)
        ? value.filter((tag): tag is string => typeof tag === "string")
        : [];
}

/**
 * Extracts learning path values from metadata.
 * `learningPaths` is canonical; `tags` remains a backward-compatible fallback.
 */
export function extractLearningPathsFromProps(
    props: Record<string, unknown> | undefined,
): string[] {
    if (!props) {
        return [];
    }

    const learningPaths = safeStringArrayExtract(props.learningPaths);
    if (learningPaths.length > 0) {
        return learningPaths;
    }

    return safeStringArrayExtract(props.tags);
}

function isDifficultyLevel(value: unknown): value is DifficultyLevel {
    return typeof value === "string" && DIFFICULTY_LEVELS.includes(value as DifficultyLevel);
}

function isResourceType(value: unknown): value is ResourceType {
    return typeof value === "string" && RESOURCE_TYPES.includes(value as ResourceType);
}

/**
 * Safely extracts difficulty level from potentially undefined/mixed-type object property
 */
export function safeDifficultyExtract(value: unknown): DifficultyLevel {
    if (isDifficultyLevel(value)) {
        return value;
    }
    return "beginner";
}

/**
 * Safely extracts resource type from potentially undefined/mixed-type object property
 */
export function safeResourceTypeExtract(value: unknown): ResourceType {
    if (isResourceType(value)) {
        return value;
    }
    return "tutorial";
}

/**
 * Extracts all available categories from a collection of resources.
 */
export const extractAvailableCategories = (
    resources: readonly LearningCenterResource[],
): string[] => Array.from(new Set(resources.map((r) => r.category))).toSorted();

/**
 * Extracts all available difficulty levels from a collection of resources.
 */
export const extractAvailableDifficulties = (
    resources: readonly LearningCenterResource[],
): DifficultyLevel[] => {
    const available = new Set(resources.map((r) => r.difficulty));
    return DIFFICULTY_LEVELS.filter((difficulty) => available.has(difficulty));
};

/**
 * Extracts all available resource types from a collection of resources.
 */
export const extractAvailableResourceTypes = (
    resources: readonly LearningCenterResource[],
): ResourceType[] => {
    const available = new Set(resources.map((r) => r.resourceType));
    return RESOURCE_TYPES.filter((type) => available.has(type));
};

/**
 * Returns a human-readable label for difficulty level
 */
export function getDifficultyLabel(difficulty: DifficultyLevel): string {
    const labels: Record<DifficultyLevel, string> = {
        beginner: "Beginner",
        intermediate: "Intermediate",
        advanced: "Advanced",
    };
    return labels[difficulty];
}

/**
 * Returns a human-readable label for resource type
 */
export function getResourceTypeLabel(type: ResourceType): string {
    const labels: Record<ResourceType, string> = {
        tutorial: "Tutorial",
        guide: "Guide",
        reference: "Reference",
        video: "Video",
        example: "Example",
    };
    return labels[type];
}

/**
 * Applies all learning center filters in a pure, testable way.
 */
export function applyLearningCenterFilters(
    resources: readonly LearningCenterResource[],
    criteria: LearningCenterFilterCriteria,
): LearningCenterResource[] {
    const {
        query = "",
        selectedCategories = [],
        selectedDifficulty = null,
        selectedLearningPath = null,
    } = criteria;

    let result = [...resources];

    const normalizedQuery = query.trim().toLowerCase();

    if (normalizedQuery) {
        result = result.filter(
            (resource) =>
                resource.resourceName.toLowerCase().includes(normalizedQuery) ||
                resource.shortDescription.toLowerCase().includes(normalizedQuery) ||
                (resource.longDescription &&
                    resource.longDescription.toLowerCase().includes(normalizedQuery)) ||
                resource.category.toLowerCase().includes(normalizedQuery),
        );
    }

    if (selectedCategories.length > 0) {
        result = result.filter((resource) => selectedCategories.includes(resource.category));
    }

    if (selectedDifficulty) {
        result = result.filter((resource) => resource.difficulty === selectedDifficulty);
    }

    if (selectedLearningPath) {
        result = result.filter((resource) => resource.learningPaths.includes(selectedLearningPath));
    }

    return result;
}
