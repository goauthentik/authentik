import type { PropSidebarItem } from "@docusaurus/plugin-content-docs";

export interface LearningCenterItem {
    id?: string;
    docId?: string;
    href?: string;
    type?: string;
    label?: string;
}

/**
 * Difficulty levels for learning resources
 */
export type DifficultyLevel = "beginner" | "intermediate" | "advanced";

/**
 * Types of learning resources
 */
export type ResourceType = "tutorial" | "guide" | "reference" | "video" | "example";

/**
 * Standardized resource interface used by LearningCenterHelper and DocCardList
 */
export interface LearningCenterResource {
    id: string;
    resourceName: string;
    category: string;
    tags: string[];
    shortDescription: string;
    longDescription?: string;
    difficulty: DifficultyLevel;
    resourceType: ResourceType;
    estimatedTime?: string;
    prerequisites?: string[];
    relatedResources?: string[];
}

/**
 * Determines if the current path is within the learning center section
 */
export function isLearningCenterPath(pathname: string): boolean {
    return /\/learning-center(\/|$)/.test(pathname);
}

/**
 * Determines if a sidebar item is a learning center article (leaf item only).
 * This is used for resource extraction in DocCardList.
 */
export function isLearningCenterItem(item: PropSidebarItem | LearningCenterItem): boolean {
    // Only check link items
    if (item.type !== "link") {
        return false;
    }

    // Check if it's a link with docId containing 'learning-center' (but not the index)
    if ("docId" in item) {
        const docId = item.docId || "";
        if (docId.includes("learning-center") && !docId.endsWith("learning-center/index")) {
            return true;
        }
    }

    // Check if it's a link with href containing '/learning-center/' (but not the index)
    if ("href" in item) {
        const href = item.href || "";
        if (
            href.includes("/learning-center/") &&
            !href.endsWith("/learning-center") &&
            !href.endsWith("/learning-center/")
        ) {
            return true;
        }
    }

    return false;
}

/**
 * Checks if a category is the top-level Learning Center category (links to index)
 */
function isLearningCenterMainCategory(item: PropSidebarItem): boolean {
    if (item.type !== "category") return false;

    // Check if this category has a link to the learning center index
    if ("link" in item && item.link) {
        const link = item.link as { type?: string; id?: string };
        if (link.type === "doc" && link.id) {
            // Check if the link ID ends with learning-center/index
            if (
                link.id.endsWith("learning-center/index") ||
                link.id === "core/learning-center/index"
            ) {
                return true;
            }
        }
    }

    // Fallback: check if the label is "Learning Center" (from autogenerated)
    if ("label" in item && item.label === "Learning Center") {
        return true;
    }

    return false;
}

/**
 * Determines if a sidebar item should be filtered from the sidebar navigation.
 * This filters:
 * - Learning center article links (leaf items)
 * - Learning center sub-categories (category-a, category-b, etc.)
 * But NOT the main Learning Center link/category itself.
 */
export function shouldFilterFromSidebar(item: PropSidebarItem | LearningCenterItem): boolean {
    // Never filter the main Learning Center category (the one with index link)
    if (isLearningCenterMainCategory(item as PropSidebarItem)) {
        return false;
    }

    // Filter learning center article links
    if (item.type === "link") {
        if ("docId" in item) {
            const docId = item.docId || "";
            // Filter articles within learning-center sub-directories (e.g., learning-center/category-a/article-a)
            // but NOT the index (learning-center/index)
            if (docId.includes("learning-center/") && !docId.endsWith("learning-center/index")) {
                return true;
            }
        }
        if ("href" in item) {
            const href = item.href || "";
            // Filter links that go deeper into learning-center (e.g., /learning-center/category-a/...)
            const pathParts = href.split("/").filter(Boolean);
            const lcIndex = pathParts.indexOf("learning-center");
            // If there are parts after "learning-center" (sub-paths), filter it
            if (lcIndex >= 0 && pathParts.length > lcIndex + 1) {
                return true;
            }
        }
    }

    // Filter learning center sub-categories (category-a, category-b, etc.)
    if (item.type === "category" && "items" in item && Array.isArray(item.items)) {
        // Check if ALL children are learning center items - if so, this is a LC sub-category
        const hasOnlyLcItems =
            item.items.length > 0 &&
            item.items.every((child) => {
                if (child.type === "link") {
                    return isLearningCenterItem(child);
                }
                if (child.type === "category") {
                    return shouldFilterFromSidebar(child);
                }
                return false;
            });
        if (hasOnlyLcItems) {
            return true;
        }
    }

    return false;
}

/**
 * Safely extracts string value from potentially undefined/mixed-type object property
 */
export function safeStringExtract(value: unknown, fallback: string = ""): string {
    return typeof value === "string" && value.trim().length > 0 ? value : fallback;
}

/**
 * Safely extracts string array from potentially undefined/mixed-type object property
 */
export function safeStringArrayExtract(value: unknown): string[] {
    return Array.isArray(value)
        ? value.filter((tag): tag is string => typeof tag === "string")
        : [];
}

/**
 * Safely extracts difficulty level from potentially undefined/mixed-type object property
 */
export function safeDifficultyExtract(value: unknown): DifficultyLevel {
    const validDifficulties: DifficultyLevel[] = ["beginner", "intermediate", "advanced"];
    if (typeof value === "string" && validDifficulties.includes(value as DifficultyLevel)) {
        return value as DifficultyLevel;
    }
    return "beginner";
}

/**
 * Safely extracts resource type from potentially undefined/mixed-type object property
 */
export function safeResourceTypeExtract(value: unknown): ResourceType {
    const validTypes: ResourceType[] = ["tutorial", "guide", "reference", "video", "example"];
    if (typeof value === "string" && validTypes.includes(value as ResourceType)) {
        return value as ResourceType;
    }
    return "tutorial";
}

/**
 * Extracts all available categories from a collection of resources.
 */
export const extractAvailableCategories = (
    resources: readonly LearningCenterResource[],
): string[] => Array.from(new Set(resources.map((r) => r.category))).toSorted();

/**
 * Extracts all available tags from a collection of resources.
 */
export const extractAvailableTags = (resources: readonly LearningCenterResource[]): string[] =>
    Array.from(new Set(resources.flatMap((r) => r.tags))).toSorted();

/**
 * Extracts all available difficulty levels from a collection of resources.
 */
export const extractAvailableDifficulties = (
    resources: readonly LearningCenterResource[],
): DifficultyLevel[] => {
    const order: DifficultyLevel[] = ["beginner", "intermediate", "advanced"];
    const available = new Set(resources.map((r) => r.difficulty));
    return order.filter((d) => available.has(d));
};

/**
 * Extracts all available resource types from a collection of resources.
 */
export const extractAvailableResourceTypes = (
    resources: readonly LearningCenterResource[],
): ResourceType[] => {
    const order: ResourceType[] = ["tutorial", "guide", "reference", "video", "example"];
    const available = new Set(resources.map((r) => r.resourceType));
    return order.filter((t) => available.has(t));
};

/**
 * Returns a human-readable label for difficulty level
 */
export function getDifficultyLabel(difficulty: DifficultyLevel): string {
    const labels: Record<DifficultyLevel, string> = {
        beginner: "Beginner",
        intermediate: "Intermediate",
        advanced: "Advanced",
    };
    return labels[difficulty];
}

/**
 * Returns a human-readable label for resource type
 */
export function getResourceTypeLabel(type: ResourceType): string {
    const labels: Record<ResourceType, string> = {
        tutorial: "Tutorial",
        guide: "Guide",
        reference: "Reference",
        video: "Video",
        example: "Example",
    };
    return labels[type];
}
